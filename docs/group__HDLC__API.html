<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tiny protocol: Tiny HDLC protocol API functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiny protocol
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
   <div id="projectbrief">Tiny communication protocol for microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tiny HDLC protocol API functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>low level HDLC protocol function - only framing  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__hdlc__handle__t.html">_hdlc_handle_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4537a8665b2abe023cb7fe40ea1bd024"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__hdlc__handle__t.html">_hdlc_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#ga4537a8665b2abe023cb7fe40ea1bd024">hdlc_struct_t</a></td></tr>
<tr class="separator:ga4537a8665b2abe023cb7fe40ea1bd024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeaf7578aed5279d3af891bd85a9f961"><td class="memItemLeft" align="right" valign="top"><a id="gabeaf7578aed5279d3af891bd85a9f961"></a>
typedef struct <a class="el" href="struct__hdlc__handle__t.html">_hdlc_handle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a></td></tr>
<tr class="memdesc:gabeaf7578aed5279d3af891bd85a9f961"><td class="mdescLeft">&#160;</td><td class="mdescRight">hdlc handle <br /></td></tr>
<tr class="separator:gabeaf7578aed5279d3af891bd85a9f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabb73b32d08d8e79eefe9385634a74bf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#gabb73b32d08d8e79eefe9385634a74bf7">hdlc_crc_t</a> { <br />
&#160;&#160;<a class="el" href="group__HDLC__API.html#ggabb73b32d08d8e79eefe9385634a74bf7a5f34a095f94c39357e31badd2feb9426">HDLC_CRC_DEFAULT</a> = 0, 
<a class="el" href="group__HDLC__API.html#ggabb73b32d08d8e79eefe9385634a74bf7a01bc9e3bb4df100ae74bd65e33223a10">HDLC_CRC_8</a> = 8, 
<a class="el" href="group__HDLC__API.html#ggabb73b32d08d8e79eefe9385634a74bf7a7ee7be32ac5752572334f3c6bc6fa5a1">HDLC_CRC_16</a> = 16, 
<a class="el" href="group__HDLC__API.html#ggabb73b32d08d8e79eefe9385634a74bf7a77c7dfdc97801651d98b6c4eb79882d3">HDLC_CRC_32</a> = 32, 
<br />
&#160;&#160;<a class="el" href="group__HDLC__API.html#ggabb73b32d08d8e79eefe9385634a74bf7a6ed874f871614e9de6358d678256a140">HDLC_CRC_OFF</a> = 0xFF
<br />
 }</td></tr>
<tr class="separator:gabb73b32d08d8e79eefe9385634a74bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa41c388433273a76460ddfbaff0f8f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#gaa41c388433273a76460ddfbaff0f8f5d">hdlc_init</a> (<a class="el" href="group__HDLC__API.html#ga4537a8665b2abe023cb7fe40ea1bd024">hdlc_struct_t</a> *hdlc_info)</td></tr>
<tr class="separator:gaa41c388433273a76460ddfbaff0f8f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d727583f0f4534c8e4688eafcec66f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#ga21d727583f0f4534c8e4688eafcec66f">hdlc_close</a> (<a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> handle)</td></tr>
<tr class="separator:ga21d727583f0f4534c8e4688eafcec66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532836280097de1c8881df8336f21075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#ga532836280097de1c8881df8336f21075">hdlc_reset</a> (<a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> handle)</td></tr>
<tr class="separator:ga532836280097de1c8881df8336f21075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911a3f1cb32dd6cadd00223e0097642c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#ga911a3f1cb32dd6cadd00223e0097642c">hdlc_run_rx</a> (<a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> handle, const void *data, int len, int *error)</td></tr>
<tr class="separator:ga911a3f1cb32dd6cadd00223e0097642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf20d86bb10361096f507838394c624c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#gaf20d86bb10361096f507838394c624c7">hdlc_run_rx_until_read</a> (<a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> handle, <a class="el" href="tiny__types_8h.html#a15bec127d9ee63658563d62e92b5261b">read_block_cb_t</a> readcb, void *user_data, uint16_t timeout)</td></tr>
<tr class="separator:gaf20d86bb10361096f507838394c624c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73156f5cc3e59c3abb880d124de78f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#ga73156f5cc3e59c3abb880d124de78f91">hdlc_set_rx_buffer</a> (<a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> handle, void *data, int size)</td></tr>
<tr class="separator:ga73156f5cc3e59c3abb880d124de78f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31d921043b4f175603114c206b6b829"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#gae31d921043b4f175603114c206b6b829">hdlc_run_tx</a> (<a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> handle)</td></tr>
<tr class="separator:gae31d921043b4f175603114c206b6b829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5cc456927145cebd82b2b560a6fa10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HDLC__API.html#ga8b5cc456927145cebd82b2b560a6fa10">hdlc_send</a> (<a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> handle, const void *data, int len, uint32_t timeout)</td></tr>
<tr class="separator:ga8b5cc456927145cebd82b2b560a6fa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>low level HDLC protocol function - only framing </p>
<p>this group implements low level HDLC functions, which implement framing only according to RFC 1662: 0x7E, 0x7D, 0x20 (ISO Standard 3309-1979). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4537a8665b2abe023cb7fe40ea1bd024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4537a8665b2abe023cb7fe40ea1bd024">&#9670;&nbsp;</a></span>hdlc_struct_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__hdlc__handle__t.html">_hdlc_handle_t</a>  <a class="el" href="group__HDLC__API.html#ga4537a8665b2abe023cb7fe40ea1bd024">hdlc_struct_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure describes configuration of lowest HDLC level Initialize this structure by 0 before passing to <a class="el" href="group__HDLC__API.html#gaa41c388433273a76460ddfbaff0f8f5d">hdlc_init()</a> function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gabb73b32d08d8e79eefe9385634a74bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb73b32d08d8e79eefe9385634a74bf7">&#9670;&nbsp;</a></span>hdlc_crc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__HDLC__API.html#gabb73b32d08d8e79eefe9385634a74bf7">hdlc_crc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HDLC CRC options, available </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabb73b32d08d8e79eefe9385634a74bf7a5f34a095f94c39357e31badd2feb9426"></a>HDLC_CRC_DEFAULT&#160;</td><td class="fielddoc"><p>If default is specified HDLC will auto select CRC option. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb73b32d08d8e79eefe9385634a74bf7a01bc9e3bb4df100ae74bd65e33223a10"></a>HDLC_CRC_8&#160;</td><td class="fielddoc"><p>Simple sum of all bytes in user payload. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb73b32d08d8e79eefe9385634a74bf7a7ee7be32ac5752572334f3c6bc6fa5a1"></a>HDLC_CRC_16&#160;</td><td class="fielddoc"><p>CCITT-16. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb73b32d08d8e79eefe9385634a74bf7a77c7dfdc97801651d98b6c4eb79882d3"></a>HDLC_CRC_32&#160;</td><td class="fielddoc"><p>CCITT-32. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb73b32d08d8e79eefe9385634a74bf7a6ed874f871614e9de6358d678256a140"></a>HDLC_CRC_OFF&#160;</td><td class="fielddoc"><p>Disable CRC field. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga21d727583f0f4534c8e4688eafcec66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d727583f0f4534c8e4688eafcec66f">&#9670;&nbsp;</a></span>hdlc_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hdlc_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdowns all hdlc activity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to hdlc instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa41c388433273a76460ddfbaff0f8f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa41c388433273a76460ddfbaff0f8f5d">&#9670;&nbsp;</a></span>hdlc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a> hdlc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#ga4537a8665b2abe023cb7fe40ea1bd024">hdlc_struct_t</a> *&#160;</td>
          <td class="paramname"><em>hdlc_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes hdlc level and returns hdlc handle or NULL in case of error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hdlc_info</td><td>pointer to hdlc_struct_t structure, which defines user-specific configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to hdlc instance or NULL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>hdlc_info structure passed to the function must be allocated all the time. </dd></dl>

</div>
</div>
<a id="ga532836280097de1c8881df8336f21075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga532836280097de1c8881df8336f21075">&#9670;&nbsp;</a></span>hdlc_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hdlc_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets hdlc state. Use this function, if hw error happened on tx or rx line, and this requires hardware change, and cancelling current operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to hdlc instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga911a3f1cb32dd6cadd00223e0097642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga911a3f1cb32dd6cadd00223e0097642c">&#9670;&nbsp;</a></span>hdlc_run_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hdlc_run_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Processes incoming data. Implementation of reading data from hw is user responsibility. If <a class="el" href="group__HDLC__API.html#ga911a3f1cb32dd6cadd00223e0097642c">hdlc_run_rx()</a> returns value less than size of data passed to the function, then <a class="el" href="group__HDLC__API.html#ga911a3f1cb32dd6cadd00223e0097642c">hdlc_run_rx()</a> must be called later second time with the pointer to and size of not processed bytes.</p>
<p>This function will return the following codes in error field:</p><ul>
<li>TINY_ERR_DATA_TOO_LARGE if receiving data fails to fit incoming buffer</li>
<li>TINY_ERR_FAILED if generic failure happened</li>
<li>TINY_ERR_WRONG_CRC if crc field of incoming frame is incorrect</li>
<li>TINY_SUCCESS if operation completed successfully</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to hdlc instance </td></tr>
    <tr><td class="paramname">data</td><td>pointer to incoming data to process </td></tr>
    <tr><td class="paramname">len</td><td>size of received data in bytes </td></tr>
    <tr><td class="paramname">error</td><td>pointer to store error code. If no error, 0 is returned. this argument can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of processed bytes from specified data buffer. </dd></dl>

</div>
</div>
<a id="gaf20d86bb10361096f507838394c624c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf20d86bb10361096f507838394c624c7">&#9670;&nbsp;</a></span>hdlc_run_rx_until_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hdlc_run_rx_until_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tiny__types_8h.html#a15bec127d9ee63658563d62e92b5261b">read_block_cb_t</a>&#160;</td>
          <td class="paramname"><em>readcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs rx cycle until full frame received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to hdlc instance </td></tr>
    <tr><td class="paramname">readcb</td><td>callback to read bytes from channel function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to readcb callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout in milliseconds to wait for new frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TINY_SUCCESS if operation completed successfully</li>
<li>TINY_ERR_FAILED if generic failure happened</li>
<li>TINY_ERR_TIMEOUT if operation cannot be completed in specified time. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae31d921043b4f175603114c206b6b829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31d921043b4f175603114c206b6b829">&#9670;&nbsp;</a></span>hdlc_run_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hdlc_run_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs transmission at hdlc level. If there is frame to send, or send is in progress, this function will call send_tx() callback multiple times. If send_tx() callback reports 0, that means that hw device is busy and in this case <a class="el" href="group__HDLC__API.html#gae31d921043b4f175603114c206b6b829">hdlc_run_tx()</a> will return immediately.</p>
<dl class="section warning"><dt>Warning</dt><dd>this function must be called from one thread only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to hdlc instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value in case of error 0 if hw is busy, or no data is waiting for sending positive number of bytes passed to hw channel. </dd></dl>

</div>
</div>
<a id="ga8b5cc456927145cebd82b2b560a6fa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b5cc456927145cebd82b2b560a6fa10">&#9670;&nbsp;</a></span>hdlc_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hdlc_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts next frame for sending. This function is thread-safe. You may call it from parallel threads.</p>
<p>If multithread_mode is specificed for hdlc protocol, then <a class="el" href="group__HDLC__API.html#ga8b5cc456927145cebd82b2b560a6fa10">hdlc_send()</a> function will wait for specified timeout until some tx thread, implemented by application, completes sending of the frame. If timeout happens, but the frame is not sent still, hdlc level rejects sending of the frame. In this case the frame will be set partially, causing RX errors on other side. Please use reasonable timeout.</p>
<p>If multithread_mode is disabled for hdlc protocol, then <a class="el" href="group__HDLC__API.html#ga8b5cc456927145cebd82b2b560a6fa10">hdlc_send()</a> function will start frame sending immediately by itself if TX line is not busy. <a class="el" href="group__HDLC__API.html#ga8b5cc456927145cebd82b2b560a6fa10">hdlc_send()</a> will block until frame is sent or timeout. If timeout happens, but the frame is not sent still, hdlc level rejects sending of the frame. In this case the frame will be set partially, causing RX errors on other side. Please use reasonable timeout.</p>
<p>If timeout is specified as 0, <a class="el" href="group__HDLC__API.html#ga8b5cc456927145cebd82b2b560a6fa10">hdlc_send()</a> function will not wait or perform send operation, but only pass data pointer to hdlc state machine. In this case, some other thread needs to or in the same thread you need to send data using <a class="el" href="group__HDLC__API.html#gae31d921043b4f175603114c206b6b829">hdlc_run_tx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to hdlc instance </td></tr>
    <tr><td class="paramname">data</td><td>pointer to new data to send (can be NULL is you need to retry sending) </td></tr>
    <tr><td class="paramname">len</td><td>size of data to send in bytes </td></tr>
    <tr><td class="paramname">timeout</td><td>time in milliseconds to wait for data to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_ERR_FAILED if generic error happens TINY_ERR_BUSY if TX queue is busy with another frame. TINY_ERR_TIMEOUT if send operation cannot be completed in specified time. TINY_ERR_INVALID_DATA if len is zero. TINY_SUCCESS if data is successfully sent </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>buffer with data must be available all the time until data are actually sent to tx hw channel. That is if you use zero timeout, you need to use callback to understand, when buffer is not longer needed at hdlc level. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>TINY_ERR_BUSY and TINY_ERR_INVALID_DATA refer to putting new frame to TX hdlc queue. </dd></dl>

</div>
</div>
<a id="ga73156f5cc3e59c3abb880d124de78f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73156f5cc3e59c3abb880d124de78f91">&#9670;&nbsp;</a></span>hdlc_set_rx_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hdlc_set_rx_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__HDLC__API.html#gabeaf7578aed5279d3af891bd85a9f961">hdlc_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets new RX buffer for hdlc protocol. This function is not thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to hdlc instance </td></tr>
    <tr><td class="paramname">data</td><td>pointer to rx buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of rx buffer in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
