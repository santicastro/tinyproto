<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tiny protocol: Tiny Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiny protocol
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
   <div id="projectbrief">Tiny communication protocol for microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tiny Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#api">Tiny Protocol API</a></li>
<li class="level1"><a href="#packet">Packet Structure</a></li>
<li class="level1"><a href="#callback">User-defined callbacks</a></li>
<li class="level1"><a href="#arduino_section">Arduino related documentation</a></li>
</ul>
</div>
<div class="textblock"><p>This is Tiny protocol implementation for microcontrollers (Arduino, Stellaris).</p>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>This protocol is intended to be used in low-memory systems, like microcontrollers (Stellaris, Arduino). It is also can be compiled for desktop Linux systems, and it is possible to build it for Windows.</p>
<h1><a class="anchor" id="api"></a>
Tiny Protocol API</h1>
<p>Library API supports C-Style functions - the basic API, and C++ API, which provides high level easy to use classes. Please refer to documentation. Basically TinyProto library provides 4 different protocol implementations:</p>
<p><a class="el" href="group__HDLC__API.html">Tiny HDLC protocol API functions</a> This is basis, which all other protocols implementations are built on top of. Hdlc api provides basic input/output operations, like FCS, escape sequencies, etc. There is no C++ wrappers for it.</p>
<p><a class="el" href="group__LIGHT__API.html">Tiny light protocol API functions</a> This is simple protocol, based on HDLC api. It simplifies sending and receiving messages on small controllers, and at the same time it has low memory consumption (800 bytes of flash). But, be careful since light version doesn't have any confirmation from remote side.</p>
<p><a class="el" href="group__HALF__DUPLEX__API.html">Tiny Half Duplex API functions</a> This is simple implementation with ACK from remote side. It needs a little more memory than light version, but it is good still for small microcontrollers. The disadvantages of hd protocol is: it doesn't use official HDLC frame format, each frame being sent must be confirmed before sending next frame. This can cause slow down in communication.</p>
<p><a class="el" href="group__FULL__DUPLEX__API.html">Tiny Full Duplex API functions</a> This is the heaviest protocol implementation in the library. For atmega controllers it requires 7KiB of flash, and at least 700 bytes to operation with 64-byte length frames. Unlike hd version, fd version of protocol is faster, as it doesn't wait for confirmation before sending next frame (thanks to window, specified in HDLC specs). Fd version of protocol uses official HDLC frame format, and implements U-frames (SABM,UA), S-frames (RR,REJ), I-frames.</p>
<h1><a class="anchor" id="packet"></a>
Packet Structure</h1>
<p>HDLC frame format: </p><pre>
     8        any len    None/8/16/32     8
 |   7E   |    DATA     |    FCS     |   7E   |
</pre><p>Full duplex hdlc uses standard hdlc frame format: </p><pre>
     8     ADDR  CONTROL     any len    None/8/16/32     8
 |   7E   | FF | hdlc ctl | USER DATA  |    FCS     |   7E   |
</pre><ul>
<li>7E is packet delimiter (commonly used on layer 2) as defined in HDLC/PPP framing. packet delimiter is used by the protocol to find first and last byte of the frame being transmitted.</li>
<li>USER DATA of any length. This field contains user data with replaced 0x7D and 0x7E bytes by special sequenced as defined in HDLC/PPP framing. Length of data is now limited on buffer used to receive frames and/or 32767 bytes (Tiny Protocol using 16-bit field to store frame length).</li>
<li>FCS is standard checksum. Depending on your selection, this is 8-bit, 16-bit or 32-bit field, or it can be absent at all. Refer to RFC1662 for examples. FCS field is also optional and can be disabled. But in this case transport errors are not detected.</li>
</ul>
<h1><a class="anchor" id="callback"></a>
User-defined callbacks</h1>
<p><a class="el" href="group__HDLC__API.html">Tiny HDLC protocol API functions</a> needs 3 callback functions, defined by a user (you may use any function names you need).</p>
<p>HDLC callbacks: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> write_func_cb(<span class="keywordtype">void</span> *user_data, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> len);</div><div class="line"><span class="keywordtype">int</span> on_frame_read(<span class="keywordtype">void</span> *user_data, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> len);</div><div class="line"><span class="keywordtype">int</span> on_frame_sent(<span class="keywordtype">void</span> *user_data, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> len);</div></div><!-- fragment --><ul>
<li>write_func_cb() is called by HDLC implementation every time, it needs to send bytes to TX channel</li>
<li>on_frame_read() is called by HDLC implementation every time, new frame arrives and checksum is correct.</li>
<li>on_frame_sent() is called by HDLC implementation every time, new frame is sent to TX. HDLC protocol requires only write_func_cb() to be defined. Other callbacks are optional. As for RX processes, your application code is responsible for reading data from RX line, then all you need to do, is to pass received bytes to HDLC implementation for processing via <a class="el" href="group__HDLC__API.html#ga911a3f1cb32dd6cadd00223e0097642c">hdlc_run_rx()</a>.</li>
</ul>
<p>All higher level protocols (<a class="el" href="group__LIGHT__API.html">Tiny light protocol API functions</a>, <a class="el" href="group__HALF__DUPLEX__API.html">Tiny Half Duplex API functions</a>, <a class="el" href="group__FULL__DUPLEX__API.html">Tiny Full Duplex API functions</a>) needs 4 callback functions, defined by a user: read_func_cb() is added. The list of callbacks:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> write_func_cb(<span class="keywordtype">void</span> *user_data, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> len);</div><div class="line"><span class="keywordtype">int</span> read_func_cb(<span class="keywordtype">void</span> *user_data, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> len);</div><div class="line"><span class="keywordtype">int</span> on_frame_read(<span class="keywordtype">void</span> *user_data, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> len);</div><div class="line"><span class="keywordtype">int</span> on_frame_sent(<span class="keywordtype">void</span> *user_data, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> len);</div></div><!-- fragment --><p>Unlike HDLC implementation, higher level protocols use different approach. They control both TX and RX channels, for example, to transparently send ACK frames, etc. That's why higher level protocols need to read_func_cb to be defined:</p>
<ul>
<li>read_func_cb() is called by higher level protocol implementation every time, it needs to read bytes from RX channel.</li>
</ul>
<h1><a class="anchor" id="arduino_section"></a>
Arduino related documentation</h1>
<p><a class="el" href="arduino.html">Arduino related API (C++)</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
